# Бумажный компьютер, используюший человека или Human Based Paper Computer (HBPC-1)

## Введение

Мой ребенок хотел понять, как работает компьютер.  
Чтоб объяснить и показать я сделал это.  
Я не специалист в проектировании процессоров, так что не претендую на предельную точность. Достаточно того, что получившееся работает.  

## Сборка

Распечатайте memory.pdf. разрежьте на горизонтальные полоски и склейте полоски вместе. Достаточно склеить столько полосок, сколько вам надо для программы. Это пямять вашего компьютера.  
Соберите конструкцию подобную тому, что на картинке ниже.  
Я использовал Lego, но можно использовать все, что взбредет в голову.  
Все кнопки нажаты и все сегменты светятся:  
[[https://github.com/DKurilo/hbpc/blob/master/img/HBPC-1-self-test.jpg|alt=Human Based Paper Computer - 1: Self Test]]
Готов к работе:
[[https://github.com/DKurilo/hbpc/blob/master/img/HBPC-1-ready-to-work.jpg|alt=Human Based Paper Computer - 1: Ready to work]]

Нижняя панель - это ЦПУ. На панели регистр процессора и 3 флага: переполнение, флаг отрицательного числа, флаг равентсва. Все очень просто.  
Верхняя панель - это модуль ввода вывода. Очень просто модуль. На нем 8 кнопок и 7 индикаторов, состоящих из 8 сегментов каждый.  
Для работы компьютера лучше использовать карандаш и ластик, чем ручку. Это позволит перезаписывать память.  

## Как это работает

Сначала надо записать программу в памяти компьютера. Используя карандаш запишите инструкции на ленте памяти. Инструкция в ячейку. Если инструкция имеет опранды, то они в следующих ячейках.  
Конечно все инструкции можно записать цифрами и если хочется посмотреть, как работает уязвимость, связанная со переполнение стека или что-то подбное, то так и надо сделать. Но мне кажется для ребенка лучше использовать инструкции, чем коды.  
Разместите память в компьютере. Первая ячейка в должна быть видна в окошке.  
И "включайте"!  
Ячейка без текста - "nop", нет операции, просто переходим к следующей инструкции.  
Прочитайте инструкцию в окошке. Если операнды не требуются (как в инструкции nop), делайте то, что надо, как ЦПУ. Если нужен один или более операндов, сдвиньте память и прочитайте данные. И затем сделайте то, что надо. Для того, чтоб было проще, опреции можно выполнять на отдельном куске бумаги.  
Если вы хотите использовать двух или более операндные инструкции, возможно вам потребуется больше регистров на ЦПУ.  

## Набор инструкций

В нашем ЦПУ очень мощный, основанный на человеческом мозге, арфметико-логический модуль. Так что можете придумать инструкции любой сложности.  
Я постарался сделать некоторый базовый набор инструкций.  

### Обозначения

R - регистр ЦПУ.  
Rn - ячейка памяти, n может быть любым натуральным числом от 0 до 255.  
K - константа ( от 0 до 255 )  
V - флаг переполнения  
N - Флаг отрицательности  
E - Флаг равенства  

### Память

R - Регистр ЦПУ (8 бит)  
R00 - Устройства ввода. 8 кнопок.  
R01 - R07 - Устройства вывода. 7 8-сегментных индикаторов.  
R08 - R255 - память общего назначения  

### Инструкции
nop - (00000000) - нет операции. Просто двигаем ленту памяти к следующей инструкции.  
ld Rn - (00000001) - загрузить содержимое Rn в R. Выставьте правильное значение для регистра ЦПУ на нижней панели.  
mov Rn - (00000010) - переместить содержимое R в ячейку памяти. Найдите ячейку Rn, удалите содержимое и запишите новые значения.  
setV - (00000011) - установить флаг V. Это делается на нижней панели.  
setN - (00000100) - установить флаг Т. Это делается на нижней панели.  
setE - (00000101) - установить флаг E. Это делается на нижней панели.  
clearV - (00000110) - очистить флаг V. Это делается на нижней панели.  
clearN - (00000111) - очистить флаг N. Это делается на нижней панели.  
clearE - (00001000) - очистить флаг E. Это делается на нижней панели.  
setR K - (00001001) - скопировать константу в R. Прочтите, что в следующей ячейке и установите R на нижней панели.  
cp Rn - (00001010) - сравнить R и содержимое Rn. Если R и Rn равны, то установить флаг E и очистить флаг N, если нет, то очистить флаг E и если R больше Rn очистить флаг N, если меньше, то установить флаг N. Вам надо найти Rn, сравнить с R и изменть флаги E и N на нижней панели. Будьте аккуратны!
jmp - (00001011) - перепрыгнуть на ячейку памяти с адресом R. Вам надо передвинуть память в нужное место.  
jmpG - (00001100) - если флаг E равен 0 и N равен 1, то перепрыгнуть на адрес, который в регистре R. Иначе просто перейти к следующей инструкции.  
jmpL - (00001101) - если флаг E равен 0 и N равен 0, то перепрыгнуть на адрес, который в регистре R. Иначе просто перейти к следующей инструкции.  
jmpE - (00001110) - если флаг E равен 1, то перепрыгнуть на адрес, который в регистре R. Иначе просто перейти к следующей инструкции.
jmpNE - (00001111) - если флаг E равен 0 и N равен 1, то перепрыгнуть на адрес, который в регистре R. Иначе просто перейти к следующей инструкции.  
jmpV - (00010000) - если флаг V равен 1 (переполнение), то перепрыгнуть на адрес, который в регистре R. Иначе просто перейти к следующей инструкции.  
jmpNV - (00010001) - если флаг V равен 0 (нет переполнения), то перепрыгнуть на адрес, который в регистре R. Иначе просто перейти к следующей инструкции.  
sum Rn - (00010010) - сложение R = R + Rn. В случае переполнения установите флаг V. Найдите ячейку Rn и прибавьте ее к R   
sub Rn - (00010011) - вычитание R = R - Rn. В случае если Rn больше R, установите флаг N. Найдите ячейку Rn и вычьтите ее из R   
and Rn - (00010100) - логическое И. R = R & Rn. Найдите Rn и выполните операцию на нижней панели.  
or Rn - (00010101) - логическое ИЛИ. R = R | Rn. Найдите Rn и выполните операцию на нижней панели.  
xor Rn - (00010111) - логическое xor (исключающее или). R = R xor Rn. Найдите Rn и выполните операцию на нижней панели.  
ls - (00011000) - сдвиг влево. Сдвиньте R влево (тоже, что умножение на 2 для натуральных чисел). Если страший байт R равен 1, установите флаг V (переполнение). Найдите Rn и выполните операцию на нижней панели.  
rs - (00011001) - сдвиг вправо. Сдвиньте R вправо (тоже самое, что деление на 2 с отбрасыванием дробной части). Найдите Rn и выполните операцию на нижней панели.  


### Пример программы

1. Бегущий огонь

```
00001000 setR 00000001  # начинаем с первого сегмента  
00001010 mov 00000001   # первый сегмент горит  
00001100 ld 00000001    # загружаем информацию про горящие сегменты  
00001110 cp 00100011    # если последний сегмент горит  
00010000 setR 00001000  # начинаем новый цикл  
00010010 jmpE  
00010011 ld 00000001    # загружаем информацию про горящие сегменты  
00010101 ls             # сдвигаем горящий сегмент  
00010110 mov 00000001   # и отправляем на вывод  
00011000 ld 00000000    # загружем нажатые кнопки  
00011010 cp 00100100    # сравниваем с маской (можете изменить этот кусок, чтоб реагировать на конкретную кнопку, подумайте, как сделать это)  
00011100 setR 00100101  # если хоть одна кнопка нажата, то завершаем программу  
00011110 jmpNE          # то завершаем программу  
00011111 setR 00001100  # если продолжаем, то переходим к следующему сегменту  
00100001 jmp  
00100010 nop            # просто nop  
00100011 10000000       # константа, чтоб проверить, что светится последний сегмент  
00100100 00000000       # маска для кнопок  
00100101 nop  
```
